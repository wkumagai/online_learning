# 戦略評価（バックテスト・リアルタイム評価）の説明書

## 1. バックテストの仕組み

バックテストとは、過去の市場データを使用して取引戦略のパフォーマンスをシミュレーションする手法です。これにより、実際の資金をリスクにさらす前に戦略の有効性を検証することができます。

### バックテストの基本的な流れ

1. **データの準備**
   - 過去の価格データ（OHLCV）の収集
   - データのクリーニングと前処理
   - トレーニング期間とテスト期間への分割

2. **戦略の実装**
   - 売買ルールのプログラミング
   - シグナル生成ロジックの実装
   - ポジションサイズの決定ロジックの実装

3. **シミュレーション実行**
   - 時系列に沿ったデータの処理
   - 売買シグナルの生成
   - 仮想的な取引の実行と記録

4. **結果の分析**
   - パフォーマンス指標の計算
   - リスク指標の計算
   - 視覚化とレポート生成

### バックテストのメリット

- **リスクフリーな検証**: 実際の資金を使わずに戦略を検証できる
- **多数の戦略比較**: 複数の戦略を短時間で比較検討できる
- **パラメータ最適化**: 戦略のパラメータを調整して最適な設定を見つけられる
- **長期パフォーマンス評価**: 数年〜数十年の長期間にわたる戦略の挙動を確認できる
- **異なる市場環境での検証**: 強気相場、弱気相場、横ばい相場など様々な環境での戦略の挙動を確認できる

### バックテストのデメリット・限界

- **過去と未来の乖離**: 過去のパフォーマンスが将来の結果を保証するものではない
- **過剰最適化のリスク**: 過去のデータに過度に適合させると将来のパフォーマンスが低下する
- **ルックアヘッドバイアス**: 将来の情報を誤って使用してしまうリスク
- **サバイバーシップバイアス**: 現在まで存続している銘柄のみを分析することによるバイアス
- **取引コストの見積もり**: 実際の取引コストを正確に再現することが難しい
- **流動性の考慮**: 特に小型株や低流動性市場での約定可能性を正確に再現できない

### バックテスト実装時の注意点

- **ウォークフォワード分析**: データを時系列で分割し、過去のデータでモデルを訓練し、未来のデータでテスト
- **適切なデータ分割**: トレーニング期間、検証期間、テスト期間を適切に分ける
- **取引コストの考慮**: 手数料、スプレッド、スリッページを現実的に見積もる
- **データ品質の確認**: 株式分割、配当調整、異常値などを適切に処理する
- **統計的有意性**: 十分な取引回数と期間でテストする

## 2. リアルタイム評価の流れ

リアルタイム評価とは、実際の市場データを使用してリアルタイムで戦略のパフォーマンスを評価するプロセスです。これには、ペーパートレード（仮想取引）と実取引の両方が含まれます。

### リアルタイム評価の基本的な流れ

1. **環境設定**
   - リアルタイムデータフィードの接続
   - 評価システムの構築
   - 監視・アラートシステムの設定

2. **段階的な展開**
   - ペーパートレード（仮想取引）での検証
   - 小規模な実取引での検証
   - 徐々にポジションサイズを拡大

3. **継続的なモニタリング**
   - パフォーマンス指標のリアルタイム計算
   - バックテスト結果との比較
   - 異常検知と自動アラート

4. **定期的な再評価**
   - 定期的なパフォーマンスレビュー
   - 市場環境の変化に応じた戦略の調整
   - 新しいデータを使用したバックテストの更新

### リアルタイム評価のメリット

- **現実的な結果**: 実際の市場条件での戦略の挙動を確認できる
- **執行品質の評価**: 注文執行の品質や遅延を評価できる
- **システム安定性の検証**: 取引システム全体の安定性と信頼性を検証できる
- **心理的要因の考慮**: 実際の取引における心理的要因の影響を評価できる
- **継続的な改善**: 戦略の問題点をリアルタイムで特定し、迅速に対応できる

### リアルタイム評価の課題

- **限られたサンプルサイズ**: 短期間では統計的に有意な結果が得られない可能性がある
- **市場環境の偏り**: 特定の市場環境でのみ評価することによるバイアス
- **システムリスク**: データフィード障害や接続問題による評価の中断
- **リソース要件**: 継続的なモニタリングに必要な計算リソースとインフラ
- **コスト**: 特にリアルタイムデータフィードや取引手数料などのコスト

### リアルタイム評価システムの実装例

```python
class RealTimeEvaluator:
    def __init__(self, strategy, data_feed, metrics_calculator):
        self.strategy = strategy
        self.data_feed = data_feed
        self.metrics_calculator = metrics_calculator
        self.trades = []
        self.current_positions = {}
        self.performance_history = []
        
    async def start(self):
        """リアルタイム評価を開始"""
        await self.data_feed.connect()
        
        # リアルタイムデータの処理
        async for market_data in self.data_feed.stream():
            # 戦略からシグナルを取得
            signals = self.strategy.generate_signals(market_data)
            
            # シグナルに基づいて仮想取引を実行
            new_trades = self._execute_virtual_trades(signals, market_data)
            self.trades.extend(new_trades)
            
            # ポジションの更新
            self._update_positions(new_trades, market_data)
            
            # パフォーマンス指標の計算
            current_metrics = self.metrics_calculator.calculate(
                self.trades, self.current_positions, market_data
            )
            self.performance_history.append(current_metrics)
            
            # アラート条件のチェック
            self._check_alerts(current_metrics)
            
            # 定期的なレポート生成（例: 1日ごと）
            if self._is_reporting_time(market_data['timestamp']):
                self._generate_report()
    
    def _execute_virtual_trades(self, signals, market_data):
        """シグナルに基づいて仮想取引を実行"""
        # 実装省略
        
    def _update_positions(self, new_trades, market_data):
        """ポジションを更新"""
        # 実装省略
        
    def _check_alerts(self, metrics):
        """アラート条件をチェック"""
        # 実装省略
        
    def _is_reporting_time(self, timestamp):
        """レポート生成タイミングかどうかを判定"""
        # 実装省略
        
    def _generate_report(self):
        """パフォーマンスレポートを生成"""
        # 実装省略
```

## 3. 代表的な評価指標

戦略の評価には様々な指標が使用されます。以下に主要な指標とその解釈を示します。

### リターン関連指標

| 指標 | 説明 | 計算方法 |
|------|------|----------|
| 累積リターン | 戦略の総合的なパフォーマンス | (最終資産価値 / 初期資産価値) - 1 |
| 年率リターン | 年率換算したリターン | (1 + 累積リターン)^(1/年数) - 1 |
| 月次リターン | 月ごとのパフォーマンス | 各月の(月末資産価値 / 月初資産価値) - 1 |
| 勝率 | 利益が出た取引の割合 | 利益取引数 / 総取引数 |
| 平均利益率 | 1取引あたりの平均利益率 | 総利益率 / 総取引数 |
| 損益比 | 平均利益と平均損失の比率 | 平均利益 / 平均損失 |

### リスク関連指標

| 指標 | 説明 | 計算方法 |
|------|------|----------|
| 最大ドローダウン | 最大の資産価値下落幅 | (ピーク時資産価値 - その後の最安値) / ピーク時資産価値 |
| ボラティリティ | リターンの変動性 | リターンの標準偏差 |
| シャープレシオ | リスク調整後リターン | (戦略リターン - 無リスク金利) / ボラティリティ |
| ソルティノレシオ | 下方リスク調整後リターン | (戦略リターン - 無リスク金利) / 下方偏差 |
| カルマーレシオ | ドローダウン調整後リターン | 年率リターン / 最大ドローダウン |
| バリューアットリスク | 特定確率での最大損失 | 信頼区間におけるリターン分布の下側確率点 |

### 取引効率指標

| 指標 | 説明 | 計算方法 |
|------|------|----------|
| 取引回数 | 総取引回数 | 買い注文と売り注文の合計 |
| 平均保有期間 | 1ポジションあたりの平均保有日数 | 全保有期間の合計 / 取引回数 |
| 取引コスト比率 | リターンに対する取引コストの比率 | 総取引コスト / 総利益 |
| スリッページ | 想定価格と実際の約定価格の差 | (約定価格 - 想定価格) / 想定価格 |
| 回転率 | 資産の入れ替え頻度 | 年間取引金額 / 平均資産額 |

### 比較指標

| 指標 | 説明 | 計算方法 |
|------|------|----------|
| アルファ | ベンチマーク対比の超過リターン | 戦略リターン - (ベータ × ベンチマークリターン) |
| ベータ | 市場との連動性 | 戦略リターンとベンチマークリターンの共分散 / ベンチマークリターンの分散 |
| 情報比率 | ベンチマーク対比のリスク調整後超過リターン | (戦略リターン - ベンチマークリターン) / トラッキングエラー |
| トラッキングエラー | ベンチマークからの乖離度 | 戦略リターンとベンチマークリターンの差の標準偏差 |

### スリッページの考慮

スリッページとは、注文時の想定価格と実際の約定価格の差のことです。バックテストでは以下の方法でスリッページを考慮できます：

1. **固定スリッページ**
   - 各取引に一定比率または金額のスリッページを適用
   - 例: 買い注文では想定価格の0.1%高く、売り注文では0.1%低く約定すると仮定

2. **ボラティリティベースのスリッページ**
   - 市場のボラティリティに応じてスリッページを変動させる
   - 例: 日中のATR（Average True Range）の10%をスリッページとして適用

3. **出来高ベースのスリッページ**
   - 取引量と市場の流動性に基づいてスリッページを計算
   - 例: 注文サイズが大きいほど、または出来高が少ないほど大きなスリッページを適用

4. **実際の約定データに基づくスリッページ**
   - 過去の実際の取引データから約定品質を分析し、現実的なスリッページモデルを構築
   - 例: 時間帯、市場状況、注文サイズなどの要因を考慮した機械学習モデル

### スリッページ実装例

```python
def apply_slippage(order_price, order_type, order_size, market_data, volatility):
    """
    スリッページを適用して実際の約定価格を計算
    
    Parameters:
    -----------
    order_price : float
        注文価格
    order_type : str
        注文タイプ ('buy' or 'sell')
    order_size : float
        注文サイズ（株数）
    market_data : dict
        市場データ（出来高など）
    volatility : float
        ボラティリティ指標（ATRなど）
        
    Returns:
    --------
    float
        スリッページ適用後の約定価格
    """
    # 基本スリッページ（価格の0.05%）
    base_slippage_pct = 0.0005
    
    # ボラティリティ要因（ATRの5%）
    volatility_factor = volatility * 0.05
    
    # 出来高要因（注文サイズが出来高の1%を超える場合に追加スリッページ）
    volume = market_data['Volume']
    volume_factor = max(0, (order_size / volume - 0.01) * 0.1) if volume > 0 else 0
    
    # 合計スリッページ率の計算
    total_slippage_pct = base_slippage_pct + volatility_factor + volume_factor
    
    # 買い注文の場合は価格が上昇、売り注文の場合は価格が下落
    if order_type == 'buy':
        execution_price = order_price * (1 + total_slippage_pct)
    else:  # sell
        execution_price = order_price * (1 - total_slippage_pct)
    
    return execution_price
```

適切な評価指標と現実的なスリッページモデルを使用することで、戦略の実際のパフォーマンスをより正確に予測することができます。バックテストとリアルタイム評価を組み合わせることで、戦略の強みと弱みを包括的に理解し、継続的に改善することが可能になります。